//
//  ObjLua.m
//  Lua
//
//  Created by ProbablyInteractive on 5/27/09.
//  Copyright 2009 Probably Interactive. All rights reserved.
//

#import "ProtocolLoader.h"

#import "wax.h"
#import "wax_class.h"
#import "wax_instance.h"
#import "wax_struct.h"
#import "wax_helpers.h"
#import "wax_gc.h"
#import "wax_server.h"

#import "lauxlib.h"
//#import "lobject.h"  ronaldochen
#import "lualib.h"


#import "WaxEngineAnalyse.h"

#ifdef QQ_LUA_SOCKET_DEBUG //added by xiaoma
//LuaSocket For Lua Debug --added by xiaoma
#import "lualoadexts.h"
#endif

//#import "wax_stdlib.h"

static void addGlobals(lua_State *L);
static int waxRoot(lua_State *L);
static int waxPrint(lua_State *L);
static int tolua(lua_State *L);
static int toobjc(lua_State *L);
static int exitApp(lua_State *L);
static int objcDebug(lua_State *L);

static lua_State *currentL;
lua_State *wax_currentLuaState() {
    
    if (!currentL) 
        currentL = lua_open();
    
    return currentL;
}

void uncaughtExceptionHandler(NSException *e) {
    NSLog(@"ERROR: Uncaught exception %@", [e description]);
    lua_State *L = wax_currentLuaState();
    
    if (L) {
        wax_getStackTrace(L);
        const char *stackTrace = luaL_checkstring(L, -1);
        wax_log(LOG_DEBUG, @"%s", stackTrace);
        lua_pop(L, -1); // remove the stackTrace
    }
}

int wax_panic(lua_State *L) {
    NSString* info = [NSString stringWithFormat:@"Lua panicked and quit: %s", luaL_checkstring(L, -1)];
    wax_log(LOG_DEBUG, @"%@", info);
    [[NSException exceptionWithName:@"QQException" reason:info userInfo:nil] raise];
    
    return 0;
}

lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);

void wax_setup() {
//	NSSetUncaughtExceptionHandler(&uncaughtExceptionHandler); 
	
    NSFileManager *fileManager = [NSFileManager defaultManager];
    [fileManager changeCurrentDirectoryPath:[[NSBundle mainBundle] bundlePath]];
    
    lua_State *L = wax_currentLuaState();
	lua_atpanic(L, &wax_panic);
    
    luaL_openlibs(L); 
	luaopen_wax_class(L);
    luaopen_wax_instance(L);
    luaopen_wax_struct(L);
	
    addGlobals(L);
	
	[wax_gc start];
}

void wax_addSearchPath(const char* path)
{
    lua_State *L = wax_currentLuaState();
	//取得全局表package
    lua_getglobal(L, "package");
    //取得其中的path字段,压入栈顶。
    lua_getfield(L, -1, "path");
    //取得当前的目录字符串。
    const char* cur_path =  lua_tostring(L, -1);
    //参数出栈，恢复堆栈。
    lua_pop(L, 1);
    //将新路径字符串加入到路径串列中，压入栈顶。
    lua_pushfstring(L, "%s;%s/?.lua", cur_path, path);
    //设置path字段值路径
    lua_setfield(L, -2, "path");
    //参数出栈，恢复堆栈。
    lua_pop(L, 1);
}

//程序启动后第一次执行脚本
void wax_start(char* initScript, const char* stdlibPath, lua_CFunction extensionFunction, ...) {
    
	wax_setup();
	
	lua_State *L = wax_currentLuaState();
	
	// Load extentions
	// ---------------
	if (extensionFunction) {
        extensionFunction(L);
		
        va_list ap;
        va_start(ap, extensionFunction);
        while((extensionFunction = va_arg(ap, lua_CFunction))) extensionFunction(L);
		
        va_end(ap);
    }
    
	// Load stdlib
	// ---------------
    if (stdlibPath) {
        
        if (luaL_loadfile(L, stdlibPath) || lua_pcall(L, 0, LUA_MULTRET, 0)) {
            const char *err = lua_tostring(L,-1);
            [[WaxEngineAnalyse GetInstance]errorOccured:WaxErrorCode_StdLuaExecuteErr errMsg:[NSString stringWithFormat:@"%s",err]];
            wax_log(LOG_FATAL, @"Error loading wax stdlib: %s\n", err);
            
        }
        
    } else {
        #ifdef WAX_STDLIB
            // If the stdlib was autogenerated and included in the source, load
            //ronaldochen
            char stdlib[] = WAX_STDLIB;
            size_t stdlibSize = sizeof(stdlib);
        #else
            char stdlib[] = "require 'wax'";
            size_t stdlibSize = strlen(stdlib);
        #endif
        
        if (luaL_loadbuffer(L, stdlib, stdlibSize, "loading wax stdlib") || lua_pcall(L, 0, LUA_MULTRET, 0)) {
            //fprintf(stderr,"Error opening wax scripts: %s\n", lua_tostring(L,-1));
            //ronaldochen
            const char *err = lua_tostring(L,-1);
            [[WaxEngineAnalyse GetInstance]errorOccured:WaxErrorCode_StdLuaExecuteErr errMsg:[NSString stringWithFormat:@"%s",err]];
            wax_log(LOG_FATAL, @"Error opening wax scripts: %s\n", err);
           
        }
    }

    
    #ifdef QQ_LUA_SOCKET_DEBUG //added by xiaoma
    //load LuaSocket For Lua Debug--added by xiaoma
    luax_loadexts(currentL);
    #endif
	

	// Run Tests or the REPL?
	// ----------------------
	NSDictionary *env = [[NSProcessInfo processInfo] environment];
    if ([[env objectForKey:@"WAX_TEST"] isEqual:@"YES"]) {
		wax_log(LOG_DEBUG, @"Running Tests\n");
		if (luaL_dostring(L, "require 'tests'") != 0) {
			wax_log(LOG_DEBUG, @"Fatal error running tests: %s\n", lua_tostring(L,-1));
        }
        exit(1);
    }
	else if ([[env objectForKey:@"WAX_REPL"] isEqual:@"YES"]) {
		printf("Starting REPL\n");
		if (luaL_dostring(L, "require 'wax.repl'") != 0) {
            wax_log(LOG_DEBUG, @"Fatal error starting the REPL: %s\n", lua_tostring(L,-1));
        }		
		exit(1);
	}
	else {
		// Load app
        // ronaldochen
        wax_runScript(initScript);
	}

}

void wax_runScript(const char *scriptFile)
{
	lua_State *L = wax_currentLuaState();
    NSString* nsInitScript = [NSString stringWithUTF8String:scriptFile];
    if (![nsInitScript hasSuffix:@".lua"]) {
        [[WaxEngineAnalyse GetInstance]startLoadUserScript];
        if (luaL_loadfile(L, scriptFile) || lua_pcall(L, 0, LUA_MULTRET, 0)) {
            const char *err = lua_tostring(L,-1);
            [[WaxEngineAnalyse GetInstance]errorOccured:WaxErrorCode_UserLuaExecuteErr errMsg:[NSString stringWithFormat:@"%s",err]];
    
            wax_log(LOG_FATAL, @"Error opening wax scripts: %s\n", err);
           
            
            return;
        }
        [[WaxEngineAnalyse GetInstance]endExecuteUserScript];

    } else {
        char appLoadString[512];
        snprintf(appLoadString, sizeof(appLoadString), "local f = '%s' require(f:gsub('%%.[^.]*$', ''))", scriptFile); // Strip the extension off the file.
        if (luaL_dostring(L, appLoadString) != 0) {
            //fprintf(stderr,"Error opening wax scripts: %s\n", lua_tostring(L,-1));
            //ronaldochen
            wax_log(LOG_FATAL, @"Error opening wax scripts: %s\n", lua_tostring(L,-1));
        }
    }
}

void wax_startWithServer() {
	wax_setup();
	[wax_server class]; // You need to load the class somehow via the wax.framework
	lua_State *L = wax_currentLuaState();
	
	// Load all the wax lua scripts
    // ronaldochen
    if (luaL_dofile(L, "scripts" "/scripts/wax/init.lua") != 0) {
        //fprintf(stderr,"Fatal error opening wax scripts: %s\n", lua_tostring(L,-1));
        //ronaldochen
        wax_log(LOG_DEBUG, @"Fatal error opening wax scripts: %s\n", lua_tostring(L,-1));
    }
	
	Class WaxServer = objc_getClass("WaxServer");
	if (!WaxServer) [NSException raise:@"Wax Server Error" format:@"Could load Wax Server"];
	
	[WaxServer start];
}

int wax_executeScriptFile(const char* filename)
{
    [[WaxEngineAnalyse GetInstance]startLoadUserScript];
    lua_State *L = wax_currentLuaState();
	//执行一个LUA脚本文件。返回值存放到nRet中。
    int nRet = luaL_dofile(L, filename);
    //    lua_gc(m_state, LUA_GCCOLLECT, 0);
	//如果出错，打印日志。
    if (nRet != 0)
    {
        const char *err =lua_tostring(L, -1);
        [[WaxEngineAnalyse GetInstance]errorOccured:WaxErrorCode_UserLuaExecuteErr errMsg:[NSString stringWithFormat:@"%s",err]];
        wax_log(LOG_FATAL, @"wax_executeScriptFile：[LUA ERROR] %s",err);
        lua_pop(L, 1);
        return nRet;
    }
    [[WaxEngineAnalyse GetInstance]endExecuteUserScript];
    return 0;
}

void wax_end() {
    [wax_gc stop];
    lua_close(wax_currentLuaState());
    currentL = 0;
}

static void addGlobals(lua_State *L) {
    lua_getglobal(L, "wax");
    if (lua_isnil(L, -1)) {
        lua_pop(L, 1); // Get rid of the nil
        lua_newtable(L);
        lua_pushvalue(L, -1);
        lua_setglobal(L, "wax");
    }
    
    lua_pushnumber(L, WAX_VERSION);
    lua_setfield(L, -2, "version");
    
    lua_pushstring(L, [[[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleVersion"] UTF8String]);
    lua_setfield(L, -2, "appVersion");
    
    lua_pushcfunction(L, waxRoot);
    lua_setfield(L, -2, "root");

    lua_pushcfunction(L, waxPrint);
    lua_setfield(L, -2, "print");    
    
#ifdef DEBUG
    lua_pushboolean(L, YES);
    lua_setfield(L, -2, "isDebug");
#endif
    
    lua_pop(L, 1); // pop the wax global off
    

    lua_pushcfunction(L, tolua);
    lua_setglobal(L, "tolua");
    
    lua_pushcfunction(L, toobjc);
    lua_setglobal(L, "toobjc");
    
    lua_pushcfunction(L, exitApp);
    lua_setglobal(L, "exitApp");
    
    lua_pushstring(L, [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0] UTF8String]);
    lua_setglobal(L, "NSDocumentDirectory");
    
    lua_pushstring(L, [[NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) objectAtIndex:0] UTF8String]);
    lua_setglobal(L, "NSLibraryDirectory");
    
    NSString *cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) objectAtIndex:0];
    lua_pushstring(L, [cachePath UTF8String]);
    lua_setglobal(L, "NSCacheDirectory");

    NSError *error = nil;
    [[NSFileManager defaultManager] createDirectoryAtPath:cachePath withIntermediateDirectories:YES attributes: nil error:&error];
    if (error) {
        wax_log(LOG_DEBUG, @"Error creating cache path. %@", [error localizedDescription]);
    }
}

static int waxPrint(lua_State *L) {
    wax_log(LOG_DEBUG, @"%s", luaL_checkstring(L, 1));
    return 0;
}

static int waxRoot(lua_State *L) {
    luaL_Buffer b;
    luaL_buffinit(L, &b);
    luaL_addstring(&b, "scripts");  //chenzhanhui
    
    for (int i = 1; i <= lua_gettop(L); i++) {
        luaL_addstring(&b, "/");
        luaL_addstring(&b, luaL_checkstring(L, i));
    }

    luaL_pushresult(&b);
                       
    return 1;
}

static int tolua(lua_State *L) {
    if (lua_isuserdata(L, 1)) { // If it's not userdata... it's already lua!
        wax_instance_userdata *instanceUserdata = (wax_instance_userdata *)luaL_checkudata(L, 1, WAX_INSTANCE_METATABLE_NAME);
        wax_fromInstance(L, instanceUserdata->instance);
    }
    
    return 1;
}

static int toobjc(lua_State *L) {
    id *instancePointer = wax_copyToObjc(L, "@", 1, nil);
    id instance = *(id *)instancePointer;
    
    wax_instance_create(L, instance, NO);
    
    if (instancePointer) free(instancePointer);
    
    return 1;
}

static int exitApp(lua_State *L) {
    exit(0);
    return 0;
}